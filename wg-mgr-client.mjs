#!/usr/bin/env node
import crypto from 'crypto';
import padTableA from 'esc-pad-table-array';
import fileReplaceContents from 'esc-file-replace-contents';
import fileReplaceSubstringBetweenComments from 'esc-file-replace-substring-between-comments';
import fs from 'fs';
import path from 'path';
import { exec, spawn } from 'child_process';
const __dirname = path.dirname(new URL(import.meta.url).pathname);
const otherPossibleServicesA = [ 'ssh', 'nginx', 'mongod' ]; // they don't need to be installed on all systems, do not edit for specific systems.

( () => { // wrapped for uglify-js
  let allConfigHash = '';
  const urlFilePath = __dirname + '/wg-mgr-client.url';
  const clientHttpsUrl = fs.readFileSync(urlFilePath).toString().split('\n')[0].trim();
  const clientHttpsHost = clientHttpsUrl.match(/(https?:\/\/[^/]+)/)[1];

  const tryGetDataOP = async () => {
    try {
      const randomString = generatePassword(100+Math.random()*100); // protect against BREACH SSL attack
      const url = `${clientHttpsUrl}?ifHashChanged=${allConfigHash}&r=${randomString}`;
      const response = await fetch(url);
      if (response.status!==200) {
        if (response.status===403) throw new Error(`Forbidden, invalid path. Fix ${urlFilePath}`);
        throw new Error(`Request failed with status code ${response.status}`);
      }
      return [1, await response.json()];
    } catch (err) {
      return [0, err];
    }
  };

  const sleepP = delay => new Promise( resolveF => setTimeout(resolveF, delay) );
  const generatePassword = length => crypto.randomBytes(Math.ceil(length * 0.75)).toString('base64').replace(/[^a-zA-Z0-9]/g, '').substring(0, length);

  const getDataOP = async () => {
    for (let i=0; ; ++i) {
      const [ success, resO ] = await tryGetDataOP();
      if (success) {
        if (i > 0) console.log(`Successfully loaded ${clientHttpsHost} after ${i+1} attempts.`);
        return resO;
      }
      let { code, address } = resO;
      console.error(`Failed to load ${clientHttpsHost} (${address}) ${code}`);
      if (i < 99) await sleepP(5000); else throw resO;
    }
  };

  const getDateS = () => (new Date()).toISOString().replace('T',' ').replace(/\.\d\d\d/,' ');
  const getUpdatedS = (info='') => `# updated ${info}${getDateS()}`;
  const getAutoGenA = ({ vpnName }) => [ '# Do not edit this file',`#This file is automatically generated by wg-mgr-client.service for the '${vpnName}' dev VPN`, getUpdatedS(), '' ];

  const mkdirIfNotExists = dir => fs.existsSync(dir) || fs.mkdirSync(dir);
  const makeBashStringExportingEnvVars = envO => { // makes a multi-line bash string exporting environment variables provided by an object, puts an empty line between prefixes FOO_ and BAR_
    const kvA = Object.entries(envO), expA = [];
    for (let i=0, key='', value='', prefix='', lastPrefix=''; i < kvA.length; ++i) {
      [ key, value ] = kvA[i]
      prefix = key.split('_')[0]; if (prefix !== lastPrefix) { expA.push(''); lastPrefix = prefix; }
      expA.push(`export ${key}='${value}'`);
    }
    return `${getUpdatedS()}\n` + expA.join('\n');
  };

  String.prototype.addS = function(n) { return n===1 || n===-1 ? this.toString() : this.toString() + 's'; };

  const checkForUpdatesP = async () => {
    const dataO = await getDataOP();
    if (dataO.hasChanged===false) return console.log(`${getDateS()} No changes reported.`);
    allConfigHash = dataO.allConfigHash;
    const { nameLabel, vpnName, vpnIp, PrivateKey, MTU, serverName, serverVpnIp, serverFQDN, serverPublicKey, ListenPort, otherNodeIpsA, otherNodeNamesA, otherNodeNameLabelsA, ipHostsA, PersistentKeepalive, extraO={} } = dataO;
    // write out extraO and appO files
    const envDir = path.join(__dirname, 'env');
    mkdirIfNotExists(envDir);
    extraO.custsA.forEach( ({ custName, custEnvO }) => {
      const { appO={} } = custEnvO;
      delete custEnvO.appO;
      const custEnvDir = path.join(envDir, custName);
      mkdirIfNotExists(custEnvDir);
      fileReplaceContents(path.join(custEnvDir, 'host_vars.sh'), makeBashStringExportingEnvVars(custEnvO));
      Object.entries(appO).forEach( ([ appName, appExtraO ]) => fileReplaceContents(path.join(custEnvDir, `${appName}_vars.sh`), makeBashStringExportingEnvVars(appExtraO)) );
    });
    // the rest is VPN related
    const restartVpnAndRelatedServices = () => {
      console.log(`Restarting wg-quick@wg_${vpnName}.service`);
      spawn('systemctl', ['restart', `wg-quick@wg_${vpnName}.service`], { stdio:'inherit' });
      exec('systemctl list-units --all', (err, stdout) => {
        if (err) return;
        const otherServicesA = otherPossibleServicesA.map( name => `${name}.service` ).filter( svcName => stdout.includes(svcName) );
        console.log(`Restarting [${otherServicesA.join(', ')}]`); // so they can receive incoming connections from the VPN
        spawn('systemctl', ['restart'].concat(otherServicesA), { stdio:'inherit' });
      });
    };
    const outA = getAutoGenA(dataO).concat(['[Interface]', `#My (client IP and key) - ${nameLabel}`, `Address = ${vpnIp}/32`, `PrivateKey = ${PrivateKey}`]);
    if (MTU) outA.push(`MTU = ${MTU}`);
    outA.push('');
    outA.push(`#Server '${serverName}' details (and gateway to other dev nodes)`);
    outA.push('[Peer]');
    outA.push(`PublicKey = ${serverPublicKey}`);
    outA.push(`Endpoint = ${serverFQDN}:${ListenPort}`);
    const allowedIpsA = [serverVpnIp].concat(otherNodeIpsA);
    const allowedNameLabelsA = [serverName].concat(otherNodeNameLabelsA);
    outA.push(`AllowedIPs = ${allowedIpsA.map(ip => `${ip}/32`).join(', ')} # [ '${ allowedNameLabelsA.join("', '") }'] respectively`);
    outA.push(`PersistentKeepalive = ${PersistentKeepalive}`);
    const clientWgConfS = outA.join('\n');
    const updatedVpnConf = fileReplaceContents(`/etc/wireguard/wg_${vpnName}.conf`, clientWgConfS);
    if (updatedVpnConf) console.log(`${getDateS()} Updated for this client:'${nameLabel}' that connects to server '${serverName}' and ${allowedNameLabelsA.length} other ${'peer'.addS(allowedNameLabelsA.length)} [ '${allowedNameLabelsA.join("', '")}' ]`);
    // update /etc/hosts
    const wgHostsS = `${getUpdatedS('automatically for wg-mgr-client ')}\n${padTableA(ipHostsA)}`;
    const updatedEtcHosts = fileReplaceSubstringBetweenComments('/etc/hosts', `wg_${vpnName}`, wgHostsS, 'append');
    if (updatedVpnConf) restartVpnAndRelatedServices();
    if (!updatedVpnConf && !updatedEtcHosts) console.log(`${getDateS()} - Up to date. No changes made.`);
  };

  const checkForUpdatesEveryMinute = async () => {
    await checkForUpdatesP();
    setTimeout(checkForUpdatesEveryMinute, 60000);
  };

  const exitError = msg => {
    process.stderr.write(`${msg}\n`);
    process.exit(1);
  };

  const mongoshP = async (label, dbName) => {
    if (dbName.indexOf('<')>-1 || dbName.indexOf('>')>-1) throw new Error(`Provide an actual dbname.`);
    const dataO = await getDataOP();
    const { otherNodeIpsA, otherNodeLabelsA } = dataO;
    const otherNodeIndex = otherNodeLabelsA.indexOf(label);
    if (otherNodeIndex===-1) return exitError(`Node label '${label}' does not exist. Available nodes are: [ '${otherNodeLabelsA.join("', '")}' ]`);
    const otherNodeIp = otherNodeIpsA[otherNodeIndex];
    const paramsA = ['--host', `${otherNodeIp}:27017`];
    if (dbName) paramsA.push(dbName);
    spawn('mongosh', paramsA, { stdio: 'inherit' });
  };

  const getMongoEnvarsP = async (label, dbName) => {
    if (dbName.indexOf('<')>-1 || dbName.indexOf('>')>-1) throw new Error(`Provide an actual dbname.`);
    const dataO = await getDataOP();
    const { otherNodeIpsA, otherNodeLabelsA } = dataO;
    const otherNodeIndex = otherNodeLabelsA.indexOf(label);
    if (otherNodeIndex===-1) return exitError(`Node label '${label}' does not exist. Available nodes are: [ '${otherNodeLabelsA.join("', '")}' ]`);
    const otherNodeIp = otherNodeIpsA[otherNodeIndex];
    console.log(`export MONGO_URL='mongodb://${otherNodeIp}:27017/${dbName}'`);
    console.log(`export MONGO_OPLOG_URL='mongodb://${otherNodeIp}:27017/local'`);
  };

  const argsA = process.argv.slice(process.argv.findIndex( s => !s.endsWith('node') && !s.endsWith('.mjs') ));
  const [ argCmd, argParam0, argParam1 ] = argsA;

  const isolatedUsageA = [ 'update', 'updateEveryMinute' ];
  const showUsageHintsP = async () => {
    const dataO = await getDataOP();
    const { isolation, otherNodeIpsA, otherNodeLabelsA } = dataO;
    const usageA = isolation ? isolatedUsageA : ( isolatedUsageA
      .concat(otherNodeLabelsA.map( label => `mongosh  ${label} <dbname>` ))
      .concat(otherNodeLabelsA.map( label => `mongoenv ${label} <dbname>` ))
    );
    process.stderr.write('Usage:\n' + usageA.map( cmd => `  wgmc ${cmd}\n` ).join(''));
  };

  switch (argCmd) {
    case 'update'           : checkForUpdatesP();                    break;
    case 'updateEveryMinute': checkForUpdatesEveryMinute();          break;
    case 'mongosh'          : mongoshP(       argParam0, argParam1); break;
    case 'mongoenv'         : getMongoEnvarsP(argParam0, argParam1); break;
    default                 : showUsageHintsP();                     break;
  }
})();
