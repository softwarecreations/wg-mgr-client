#!/usr/bin/env node
import crypto from 'crypto';
import padTableA from 'esc-pad-table-array';
import fileReplaceContents from 'esc-file-replace-contents';
import fileReplaceSubstringBetweenComments from 'esc-file-replace-substring-between-comments';
import { getCmdDataP } from 'esc-get-cmd-data-passthru-async';
import { runInteractivelyP } from 'esc-get-interactive-cmd-result-async';
import fs from 'fs';
import path from 'path';
import { spawn } from 'child_process';
const __dirname = path.dirname(new URL(import.meta.url).pathname);
const otherPossibleServicesA = [ 'ssh', 'nginx', 'mongod' ]; // they don't need to be installed on all systems, do not edit for specific systems.
const addPropertyF   = (type,name,x) => { if (type[name]===undefined) type[name]=x; else showError(new Error(`${type.name}.${name} already exists.`)); };
addPropertyF(Object, 'get', o => o!==null && typeof o==='object' ? o : showError(new Error(`Expected object, but it was:${fancyTypeof(o,1)}`)) );
addPropertyF(Object, 'getKeys', o => Object.keys(Object.get(o)) );
addPropertyF(Object, 'withoutKeys' , (o, keys)  => { if (typeof keys==='string') keys=[keys]; return Object.fromEntries(Object.getKeys(o).filter(Array.isArray(keys) ? key => !keys.includes(key) : key => keys[key]===undefined).map( key => [ key, o[key] ] )) });
const addPrototypeF  = (type,name,f) => { if (type.prototype[name]===undefined) type.prototype[name]=f; else showError(new Error(`${type.name}.prototype.${name} already exists.`)); };
addPrototypeF(String, 'addS', function(n) { return n===1 || n===-1 ? this.toString() : this.toString() + 's'; });
addPrototypeF(String, 'firstMatch', function(regex, ifNotFound) {
  const matchA = this.match(regex);
  if (matchA!==null) {
    if (matchA.length > 2) return matchA[1] ?? matchA[2];
    if (matchA.length > 1) return matchA[1];
  }
  if (ifNotFound===undefined) throw new Error(`Could not find capture group of regex ${regex} in string: ${this}`); else return ifNotFound;
});

( () => { // wrapped for uglify-js
  const lastBackupTsM = new Map();
  let allConfigHash = '';
  const urlFilePath = __dirname + '/wg-mgr-client.url';
  const clientHttpsUrl = fs.readFileSync(urlFilePath).toString().split('\n')[0].trim();
  const clientHttpsHost = clientHttpsUrl.match(/(https?:\/\/[^/]+)/)[1];

  const tryGetDataOP = async () => {
    try {
      const randomString = generatePassword(100+Math.random()*100); // protect against BREACH SSL attack
      const url = `${clientHttpsUrl}?ifHashChanged=${allConfigHash}&r=${randomString}`;
      const response = await fetch(url);
      if (response.status!==200) {
        if (response.status===403) throw new Error(`Forbidden, invalid path. Fix ${urlFilePath}`);
        throw new Error(`Request failed with status code ${response.status}`);
      }
      return [1, await response.json()];
    } catch (err) {
      return [0, err];
    }
  };

  const sleepP = delay => new Promise( resolveF => setTimeout(resolveF, delay) );
  const generatePassword = length => crypto.randomBytes(Math.ceil(length * 0.75)).toString('base64').replace(/[^a-zA-Z0-9]/g, '').substring(0, length);

  const getDataOP = async () => {
    for (let attempts=1; ; ++attempts) {
      const [ success, resO ] = await tryGetDataOP();
      if (success) {
        if (attempts > 1) console.log(`Successfully loaded ${clientHttpsHost} after ${attempts} attempts.`);
        return { attempts, dataO:resO };
      }
      let { code, address } = resO;
      console.error(`Failed to load ${clientHttpsHost} (${address}) ${code}`);
      if (attempts < 100) await sleepP(5000); else throw resO;
    }
  };

  const getDateS = () => (new Date()).toISOString().replace('T',' ').replace(/\.\d\d\d/,' ');
  const getUpdatedS = (info='') => `# updated ${info}${getDateS()}`;
  const getAutoGenA = ({ vpnName }) => [ '# Do not edit this file',`#This file is automatically generated by wg-mgr-client.service for the '${vpnName}' dev VPN`, getUpdatedS(), '' ];

  const mkdirIfNotExists = dir => fs.existsSync(dir) || fs.mkdirSync(dir);
  const makeBashStringExportingEnvVars = envO => { // makes a multi-line bash string exporting environment variables provided by an object, puts an empty line between prefixes FOO_ and BAR_
    const kvA = Object.entries(envO), expA = [], defTblA=[];
    for (let i=0, key='', value='', isDefaultValue=0, wasDefaultValue=0, prefix='', suffix='', lastPrefix='', lastSuffix=''; i < kvA.length; ++i) {
      [ key, value ] = kvA[i];
      isDefaultValue = key[0]==='_';
      if (isDefaultValue) key = key.slice(1);
      prefix = key.firstMatch(/^([a-z\d]+)[A-Z]|([A-Z\d]+)_?[A-Za-z\d]*/, key);
      suffix = key.firstMatch(/[a-z\d_]*?([A-Z][a-z]+|[A-Z]+)$/, key);
      if (isDefaultValue) {
        if (defTblA.length > 0 && (prefix!==lastPrefix && suffix!==lastSuffix)) defTblA.push(['']);
        defTblA.push([`[[ $${key}`, `]] || export ${key}="${value}"` ]);
      } else {
        if (wasDefaultValue) {
          expA.push('', padTableA(defTblA, { colDelim:' ' }));
          defTblA.length = 0;
        }
        if (wasDefaultValue || (prefix!==lastPrefix && suffix!==lastSuffix)) expA.push('');
        expA.push(`export ${key}="${value}"`);
      }
      lastPrefix = prefix;
      lastSuffix = suffix;
      wasDefaultValue = isDefaultValue;
    }
    if (defTblA.length!==0) expA.push('', padTableA(defTblA, { colDelim:' ' }));
    return `${getUpdatedS()}\n` + expA.join('\n');
  };

  let checkedCount = 0;
  const checkForUpdatesP = async () => {
    const { attempts, dataO } = await getDataOP();
    const { nameLabel, vpnName, vpnIp, PrivateKey, MTU, serverName, serverVpnIp, serverFQDN, serverPublicKey, ListenPort, otherNodeIpsA, otherNodeNamesA, otherNodeNameLabelsA, ipHostsA, PersistentKeepalive, extraO={} } = dataO;
    const restartVpnAndRelatedServicesP = async () => {
      for (let i=0; i<3; ++i) {
        await runInteractivelyP('systemctl', ['restart', `wg-quick@wg_${vpnName}.service`]);
        // wait for a successful ping
        let [ _retCode, outA ] = await getCmdDataP('ping', ['-i', '0.5', '-W', '2', '-c', '5', 'wg-router'], { filterOnly:'bytes from', until:'bytes from', verbosity:1 });
        if (outA.length!==0) break;
        await sleepP(1000);
      }
      // restart services that are affected by VPN
      const [ _retCode, haveServicesA, _errA ] = await getCmdDataP('systemctl', ['list-units', '--all'], { capture:/([\w-]+)\.service/, verbosity:1, passthru:false });
      const restartServicesA = haveServicesA.filter( haveService => otherPossibleServicesA.includes(haveService) );
      if (restartServicesA.length!==0) await getCmdDataP('systemctl', ['restart'].concat(restartServicesA));
    };
    if (dataO.hasChanged===false) {
      // console.log(`${getDateS()} No changes reported.`);
      return pingAndRestartVpnIfNecessaryP(1);
    }
    allConfigHash = dataO.allConfigHash;
    // write out extraO and appsO files
    const envDir = path.join(__dirname, 'env');
    mkdirIfNotExists(envDir);
    extraO.custsA.forEach( ({ custName, custEnvO }) => {
      const { appsO={} } = custEnvO;
      delete custEnvO.appsO;
      const custEnvDir = path.join(envDir, custName);
      mkdirIfNotExists(custEnvDir);
      fileReplaceContents(path.join(custEnvDir, 'host_vars.sh'), makeBashStringExportingEnvVars(custEnvO));
    //   Object.entries(appsO).forEach( ([ appName, fullAppExtraO ]) => {
    //     const { backblazeO } = fullAppExtraO;
    //     if (backblazeO) {
    //       const { itemsA, keyId, keyName, applicationKey } = backblazeO;
    //       console.log(appName, 'backblazeO', backblazeO);
    //       itemsA.forEach( item => {
    //         const lastBackupTs = lastBackupTsM.get(`${appName}_${item}_cold`) || 0;
    //         // if ()

    //       });
    //     }
    //     const appExtraO = Object.withoutKeys(fullAppExtraO, 'backblazeO');
    //     fileReplaceContents(path.join(custEnvDir, `${appName}_vars.sh`), makeBashStringExportingEnvVars(appExtraO))
    //  });
    });
    // the rest is VPN related
    const outA = getAutoGenA(dataO).concat(['[Interface]', `#My (client IP and key) - ${nameLabel}`, `Address = ${vpnIp}/32`, `PrivateKey = ${PrivateKey}`]);
    if (MTU) outA.push(`MTU = ${MTU}`);
    outA.push('');
    outA.push(`#Server '${serverName}' details (and gateway to other dev nodes)`);
    outA.push('[Peer]');
    outA.push(`PublicKey = ${serverPublicKey}`);
    outA.push(`Endpoint = ${serverFQDN}:${ListenPort}`);
    const allowedIpsA = [serverVpnIp].concat(otherNodeIpsA);
    const allowedNameLabelsA = [serverName].concat(otherNodeNameLabelsA);
    outA.push(`AllowedIPs = ${allowedIpsA.map(ip => `${ip}/32`).join(', ')} # [ '${ allowedNameLabelsA.join("', '") }'] respectively`);
    outA.push(`PersistentKeepalive = ${PersistentKeepalive}`);
    const clientWgConfS = outA.join('\n');
    const updatedVpnConf = fileReplaceContents(`/etc/wireguard/wg_${vpnName}.conf`, clientWgConfS);
    if (updatedVpnConf) console.log(`${getDateS()} Updated for this client:'${nameLabel}' that connects to server '${serverName}' and ${allowedNameLabelsA.length} other ${'peer'.addS(allowedNameLabelsA.length)} [ '${allowedNameLabelsA.join("', '")}' ]`);
    // update /etc/hosts
    const wgHostsS = `${getUpdatedS('automatically for wg-mgr-client ')}\n${padTableA(ipHostsA)}`;
    const updatedEtcHosts = fileReplaceSubstringBetweenComments('/etc/hosts', `wg_${vpnName}`, wgHostsS, 'append');
    const shouldRestartVpn = updatedVpnConf || attempts > 1 || ++checkedCount===1;
    if (shouldRestartVpn) restartVpnAndRelatedServicesP(); else pingAndRestartVpnIfNecessaryP(3);
    if (!updatedVpnConf && !updatedEtcHosts) console.log(`${getDateS()} - Up to date. No changes made.`);
  };

  const pingAndRestartVpnIfNecessaryP = async (verbosity=3) => {
    const [ _retCode, outA, _errA ] = await getCmdDataP('ping', ['-i', '0.5', '-W', '2', '-c', '5', 'wg-router'], { capture:/bytes from.+time=([\d.]+)/, until:'bytes from', passthru:false, verbosity:1 });
    if (outA.length!==0) {
      if (verbosity >= 2) console.log(`Ping wg-router succeeded: ${outA[0]} ms`);
    } else {
      if (verbosity >= 1) console.log('Ping wg-router failed, restarting VPN related services.');
      restartVpnAndRelatedServicesP();
    }
  };

  const checkForUpdatesEveryMinute = async () => {
    await checkForUpdatesP();
    setTimeout(checkForUpdatesEveryMinute, 60000);
  };

  const exitError = msg => {
    process.stderr.write(`${msg}\n`);
    process.exit(1);
  };

  const mongoshP = async (label, dbName) => {
    if (dbName.indexOf('<')>-1 || dbName.indexOf('>')>-1) throw new Error(`Provide an actual dbname.`);
    const { dataO } = await getDataOP();
    const { otherNodeIpsA, otherNodeLabelsA } = dataO;
    const otherNodeIndex = otherNodeLabelsA.indexOf(label);
    if (otherNodeIndex===-1) return exitError(`Node label '${label}' does not exist. Available nodes are: [ '${otherNodeLabelsA.join("', '")}' ]`);
    const otherNodeIp = otherNodeIpsA[otherNodeIndex];
    const paramsA = ['--host', `${otherNodeIp}:27017`];
    if (dbName) paramsA.push(dbName);
    spawn('mongosh', paramsA, { stdio: 'inherit' });
  };

  const argsA = process.argv.slice(process.argv.findIndex( s => !s.endsWith('node') && !s.endsWith('.mjs') ));
  const [ argCmd, argParam0, argParam1 ] = argsA;

  const isolatedUsageA = [ 'update', 'updateEveryMinute' ];
  const showUsageHintsP = async () => {
    const { dataO } = await getDataOP();
    const { isolation, otherNodeIpsA, otherNodeLabelsA } = dataO;
    const usageA = isolation ? isolatedUsageA : ( isolatedUsageA
      .concat(otherNodeLabelsA.map( label => `mongosh  ${label} <dbname>` ))
      .concat(otherNodeLabelsA.map( label => `mongoenv ${label} <dbname>` ))
    );
    process.stderr.write('Usage:\n' + usageA.map( cmd => `  wgmc ${cmd}\n` ).join(''));
  };

  switch (argCmd) {
    case 'update'           : checkForUpdatesP();                    break;
    case 'updateEveryMinute': checkForUpdatesEveryMinute();          break;
    case 'mongosh'          : mongoshP(       argParam0, argParam1); break;
    default                 : showUsageHintsP();                     break;
  }
})();
