#!/usr/bin/env node
const fs=require("fs");const https=require("https");(()=>{const n=__dirname+"/wg-mgr-client.url";const t=fs.readFileSync(n).toString().split("\n")[0].trim();const r=t.match(/(https?:\/\/[^/]+)/)[1];const a=()=>new Promise(o=>{const e=https.get(t,e=>{if(e.statusCode!==200){if(e.statusCode===403)return rejectF(new Error(`Forbidden, invalid path. Fix ${n}`));return rejectF(new Error(`Request failed with status code ${e.statusCode}`))}const t=[];e.on("data",e=>t.push(e));e.on("end",()=>{try{o([1,JSON.parse(t.join(""))])}catch(e){o([0,e])}})});e.on("error",e=>o([0,e]))});const c=t=>new Promise(e=>setTimeout(e,t));const y=async()=>{for(let o=0;;++o){const[n,s]=await a();if(n){if(o>0)console.log(`Successfully loaded ${r} after ${o+1} attempts.`);return s}let{code:e,address:t}=s;console.error(`Failed to load ${r} (${t}) ${e}`);if(o<99)await c(5e3);else throw s}};const N=(e,t)=>t!==e?`${e} (${t})`:e;const P=({vpnName:e})=>["# Do not edit this file",`#This file is automatically generated by wg-mgr-client.service for the '${e}' dev VPN`,""];String.prototype.addS=function(e){return e===1||e===-1?this.toString():this.toString()+"s"};const e=async()=>{const e=await y();const{name:t,label:o,vpnName:n,vpnIp:s,PrivateKey:r,MTU:a,serverName:c,serverVpnIp:i,serverFQDN:d,serverPublicKey:l,ListenPort:p,otherNodeIpsA:h,otherNodeNameLabelsA:$,PersistentKeepalive:u}=e;const f=N(t,o);const g=P(e).concat(["[Interface]",`#My (client IP and key) - ${f}`,`Address = ${s}/32`,`PrivateKey = ${r}`]);if(a)g.push(`MTU = ${a}`);g.push("");g.push(`#Server '${c}' details (and gateway to other dev nodes)`);g.push("[Peer]");g.push(`PublicKey = ${l}`);g.push(`Endpoint = ${d}:${p}`);const m=[i].concat(h);const w=[c].concat($);g.push(`AllowedIPs = ${m.map(e=>`${e}/32`).join(", ")} # [ '${w.join("', '")}'] respectively`);g.push(`PersistentKeepalive = ${u}`);const v=g.join("\n");const b=`/etc/wireguard/wg_${n}.conf`;if(fs.existsSync(b)&&fs.readFileSync(b).toString()===v)return console.log(`No change in ${b}`);fs.writeFileSync(b,v);console.log(`Wrote new conf ${b} client:${f} that connects to server '${c}' and ${w.length} other ${"peer".addS(w.length)} [ '${w.join("', '")}' ]`)};const i=e=>{process.stderr.write(`${e}\n`);process.exit(1)};const o=async(e,t)=>{if(t.indexOf("<")>-1||t.indexOf(">")>-1)throw new Error(`Provide an actual dbname.`);const o=await y();const{otherNodeIpsA:n,otherNodeLabelsA:s}=o;const r=s.indexOf(e);if(r===-1)return i(`Node label '${e}' does not exist. Available nodes are: [ '${s.join("', '")}' ]`);const a=n[r];const c=["--host",`${a}:27017`];if(t)c.push(t);require("child_process").spawn("mongosh",c,{stdio:"inherit"})};const s=async(e,t)=>{if(t.indexOf("<")>-1||t.indexOf(">")>-1)throw new Error(`Provide an actual dbname.`);const o=await y();const{otherNodeIpsA:n,otherNodeLabelsA:s}=o;const r=s.indexOf(e);if(r===-1)return i(`Node label '${e}' does not exist. Available nodes are: [ '${s.join("', '")}' ]`);const a=n[r];console.log(`export MONGO_URL='mongodb://${a}:27017/${t}'`);console.log(`export MONGO_OPLOG_URL='mongodb://${a}:27017/local'`)};const[d,l,p,h,$]=process.argv;const u=async()=>{const e=await y();const{isolation:t,otherNodeIpsA:o,otherNodeLabelsA:n}=e;const s=t?["updateWgConf"]:["updateWgConf"].concat(n.map(e=>`mongosh  ${e} <dbname>`)).concat(n.map(e=>`mongoenv ${e} <dbname>`));process.stderr.write("Usage:\n"+s.map(e=>`  ${l} ${e}\n`).join(""))};switch(p){case"updateWgConf":e();break;case"mongosh":o(h,$);break;case"mongoenv":s(h,$);break;default:u();break}})();